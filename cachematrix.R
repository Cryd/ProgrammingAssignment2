# The pair of functions 'makeCacheMatrix' and 'cacheSolve' compute
# the inverse of a matrix and store it in the cache. Subsequent calls
# of 'cacheSolve' will fetch the inverse matrix from the cache
# instead of re-computing.

# The function 'makeCacheMatrix' takes a matrix 'x' as argument and 
# returns a list of anonymous functions. The functions are used by the
# function 'cacheSolve' to calculate the inverse of the matrix 'x'
# and to cache the inverse in the enclosing environment of
# 'makeCacheMatrix'. 

makeCacheMatrix <- function(x = matrix()) {
		## return a list of functions to compute and store the inverse
        inv <- NULL	# 'inv' is the cached inverse of 'x' and is
					# reset to NULL every time 'makeCacheMatrix'
					# is called
					  
		# create the functions that will be called by 'cacheSolve'
        set <- function(y) {    # save the original matrix and reset 
                                # the inverse
								
                x <<- y			# cache the original matrix in the
								# enclosing environment
                inv <<- NULL	# idem for the reset inverse matrix
        }
        get <- function() x     # fetch the original matrix from cache
        setinv <- function(solve) inv <<- solve # compute inverse, 
											# superassign it to 'inv'
        getinv <- function() inv	# fetch 'inv' from cache
		
		# output list of functions	to be the argument of 'cacheSolve'
        list(set = set, get = get, setinv = setinv, getinv = getinv)
}

# The function 'cacheSolve' takes as argument the list returned by
# 'makeCacheMatrix'. When called the first time, 'cacheSolve'
# returns the inverse of matrix 'x'. The inverse matrix is cached in
# the environment of 'makeCacheMatrix'. When called subsequently for
# the same 'x', 'cacheSolve' fetches the inverse from the cache.
# Although the assignment limited the 'x' to invertible matrices, 
# the 'cacheSolve' function can handle the error generated by a
# non-invertible matrix.

cacheSolve <- function(x, ...) {
		
        inv <- x$getinv()	# fetch the inverse matrix from cache
        if(!is.null(inv)) {	# if "inv" is not NULL returns the
							# precomputed inverse
                message("getting cached data")
                return(inv)
        }
		
		# handle the cases of non-invertible matrices by returning NULL
        data <- x$get()		# fetches the original matrix
        if(ncol(data)!=nrow(data))	# compare number of rows and
									# columns
                {message("Not a square matrix ==> non-invertible")
                return()}
        if(det(data)==0)			# compute the determinant
                {message("Singular matrix ==> non-invertible")
                return()}
				
		# return the inverse of "x"				
        inv <- solve(data)	# assign computed inverse of "x" 
        x$setinv(inv)		# cache "inv"
        inv
}

# **NOTE**: The test of the pair 'makeCacheMatrix' + 'cacheSolve'
# can be done by feeding 'cacheSolve' three lists generated by
# 'makeCacheMatrix' as follows:
#    1) create three 'x' matrices (for example):
#       > invertible <- matrix(c(50,2:15,50),4,4)
#       > nonsquare <- matrix(1:20,4,5)
#       > nonzero <- matrix(1:16,4,4)
#    2) apply 'makeCacheMatrix' to each matrix:
#       > testinv <- makeCacheMatrix(invertible)
#       > testnsq <- makeCacheMatrix(nonsquare)
#       > testnz <- makeCacheMatrix(nonzero)
#    3) apply 'cacheSolve' to each list:
#       > cacheSolve(testnsq) # verify error handling
#       > cacheSolve(testnz)  # verify error handling
#       > cacheSolve(testinv) # verify inverse
#       > cacheSolve(testinv) # verify cache